<script>
        // 注意：数组和对象是引用类型，所以数组和对象的比较是引用值的比较，两个单独的相同数组是不可能相等的，而如果数组b复制数组
        // a是可以相等的，因为复制的是引用值。
        

        // 不可变的原始值和可变的对象引用
        var s = "hello";
        console.log(s.toUpperCase());   // HELLO:但并没有改变s的值
        console.log(s);         // hello:原始字符串的值并未改变

        // 原始值的比较是值的比较：只有在它们的值相等时它们才相等，而对于字符串，当且仅当他们的长度相等且每个索引的字符都相等时，js才认为它们是相等的。
        // 对象和原始值不同，首先，它们是可变的--它们的值是可修改的
        var o = { x:1 };        // 定义一个对象
        o.x = 2;
        o.y = 3;
        console.log(o);     //{x:2,y:3}：通过修改对象属性值来更改对象，再次更改这个对象，给他增加一个新属性

        var a = [1,2,3]
        a[0] = 0;
        a[3] = 4;
        console.log(a);     //[0,2,3,4]

        // 对象的比较并非值得比较，即使两个对象包含同样的属性及相同的值，它们也是不相等的，各个索引元素完全相等的两个数组也不相等
        var b = { x:1 },c = { x:1 };    // 具有相同属性的两个对象
        console.log(b === c);       //false：两个单独的对象永不相等
        var d = [],e = [];          // 两个单独的数组
        console.log(d === e);       //false：两个单独的数组永不相等
        var dd = [1],ee = [1];
        console.log(dd === ee)      //false

        // 我们通常将对象成为引用类型，以此来和js基本类型区分开，对象值值都是引用，对象的比较都是引用的比较，当且仅当它们引用
        // 同一个基对象时，它们才相等。
        var f = [];             //定义一个空数组的变量f
        var g = f;              //变量g引用同一个数组
        g[0] = 1;               //通过变量g来修改引用的数组
        console.log(f[0]);      // 1：变量f也会修改
        console.log(f === g);   //true：因为f,g引用的是用一个数组，所以它们相等

        //将对象或数组赋值给一个变量，仅仅是赋值的引用值，对象本身并没有复制一次。如果想得到一个对象或数组的副本，必须
        //【显式？】复制对象的每个属性或数组的每个元素。
        var h = ['a','b','c'];
        var j = [];
        for(var i = 0;i<h.length;i++){
            j[i] = h[i];
        }
        console.log(j);     //["a","b","c"]

        // 同样的，如果我们想比较两个单独的对象或数组，则必须比较它们的属性或元素。
        function equalArrays(h,j){
            if(h.length != j.length) return false;
            for(var i = 0;i<h.length;i++){
                if (h[i] !== j[i]) return false;
            }
            return true;
        }        
        console.log(equalArrays(h,j))       //true:因为j复制了h，所以它们的长度相等，元素相等，所以想等。



    </script>
